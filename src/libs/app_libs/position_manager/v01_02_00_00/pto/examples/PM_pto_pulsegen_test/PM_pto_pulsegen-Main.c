//----------------------------------------------------------------------------------
//	FILE:			PM_pto_pulsegen-Main.C
//
//	Description:	Example project for using PM pto_pulsegen Library.
//					Includes PM_pto_pulsegen_lib library and corresponding include files.
//
//	Version: 		1.0
//
//  Target:  		TMS320F28379D
//
//----------------------------------------------------------------------------------
//  Copyright Texas Instruments © 2004-2015
//----------------------------------------------------------------------------------
//  Revision History:
//----------------------------------------------------------------------------------
//  Date	  | Description / Status
//----------------------------------------------------------------------------------
// Mar 2017  - Example project for PM PTO Pulsegen Library Usage
//----------------------------------------------------------------------------------
// Test Usage:
// Refer to the PM PTO PulseGen Library and related documentation on controlSuite for library functions and usage details
// pto_pulsegen.c has detials of pto function initialization and ISR used for updated the PTO pto_setOptions function
// Test case by default uses the Interrupt generated by CLB (PTO library function) for controlling PTO parameters
// Users can optionally change this to the CPU timer based update provided in this file
// Make sure the pto interrupt in pto_pulsegen.c is disabled if cputimer interrupt is used for updates

#include "F28x_Project.h"    // Device Headerfile and Examples Include File
#include "pto_pulsegen.h"		 // Include file for pto_pulsegen interface

__interrupt void cpu_timer0_isr(void);
void configPTOTimerInt(void);

extern uint32_t remVal;
uint16_t j=0;

void main(void) {

// Initialize System Control:
// PLL, WatchDog, enable Peripheral Clocks
// This example function is found in the F2837xD_SysCtrl.c file.
	InitSysCtrl();
// Step 3. Clear all interrupts and initialize PIE vector table:
// Disable CPU interrupts
	DINT;

// Initialize the PIE control registers to their default state.
// The default state is all PIE interrupts disabled and flags
// are cleared.
// This function is found in the F2837xD_PieCtrl.c file.
	InitPieCtrl();

// Disable CPU interrupts and clear all CPU interrupt flags:
	IER = 0x0000;
	IFR = 0x0000;

// Initialize the PIE vector table with pointers to the shell Interrupt
// Service Routines (ISR).
	InitPieVectTable();

// Uncomment the line below to enable cputimer based updates for PTO function
// if using cputimer based updates disable the pto interrupts in pto_pulsegen.c
// Make sure the timer updates give enough time for PTO library function calls
// if there is conflicts in cputimer updates vs pto function updates, there can be
// unpredictable pulse generation behavior

//	configPTOTimerInt();

//Initialization routine for pto_pulsegen operation - defined in pto_pulsegen.c
//Configures the peripherals and enables clocks for required modules
//Configures GPIO and XBar as needed for pto_pulsegen operation

	pto_pulsegen_Init();
	DELAY_US(800L); 	//Delay 800us

		PM_pto_pulsegen_startOperation();
		remVal = PM_pto_pulsegen_runPulseGen(50, 50, 1000, 1000, 500, 1, 1);

//Infinite loop - PtoIsr updates the pulsegen options - in pulsegen.c
	while(1)
	{
		asm(" NOP");
		asm(" NOP");
		asm(" NOP");
		asm(" NOP");
	}
}

__interrupt void cpu_timer0_isr(void)
{
//uint32_t	retval1; // can be optionally used to accumulate reminder for the next period
		if(j==0)
		{
// pto_setOptions(numPulses, Period, ptoInterruptTime, ptoDirection, run)
			remVal=pto_setOptions(4, 1000, 500, 1,	1);
			j=1;
		}
		else
		{
			remVal=pto_setOptions(25, 1000, 500, 0, 1);
			j=0;
		}

// Acknowledge this interrupt to receive more interrupts from group 1
		PieCtrlRegs.PIEACK.all = PIEACK_GROUP1;
}


void configPTOTimerInt (void)
{
// Interrupts that are used in this example are re-mapped to
// ISR functions found within this file.
//
	EALLOW;  // This is needed to write to EALLOW protected registers
	PieVectTable.TIMER0_INT = &cpu_timer0_isr;
	EDIS;    // This is needed to disable write to EALLOW protected registers

// Step 4. Initialize the Device Peripheral. This function can be found in F2837xD_CpuTimers.c
	InitCpuTimers();

// Configure CPU-Timer 0, 200MHz CPU Freq, 100us second Period (in uSeconds)
	ConfigCpuTimer(&CpuTimer0, 200, 10);

// To ensure precise timing, use write-only instructions to write to the
// entire register. Therefore, if any of the configuration bits are changed in
// ConfigCpuTimer and InitCpuTimers (in F2837xD_cputimervars.h), the below
// settings must also be updated.
//
	CpuTimer0Regs.TCR.all = 0x4000;

//
// Step 5. User specific code, enable interrupts:
// Enable CPU int1 which is connected to CPU-Timer 0
// to CPU-Timer 2:
//
	IER |= M_INT1;
//
// Enable TINT0 in the PIE: Group 1 interrupt 7
//
	PieCtrlRegs.PIEIER1.bit.INTx7 = 1;

//
// Enable global Interrupts and higher priority real-time debug events:
//
	EINT;  // Enable Global interrupt INTM
	ERTM;  // Enable Global realtime interrupt DBGM

}
// End of file
